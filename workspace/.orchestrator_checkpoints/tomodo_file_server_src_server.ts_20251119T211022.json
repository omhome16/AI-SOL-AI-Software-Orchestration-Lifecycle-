{
  "id": "tomodo_file_server_src_server.ts_20251119T211022",
  "project_id": "tomodo",
  "step": "file:server/src/server.ts",
  "timestamp": "2025-11-19T21:10:22.190895+05:30",
  "payload": {
    "file": "server/src/server.ts",
    "path_on_disk": "server\\src\\server.ts",
    "preview": "/**\n * @file server.ts\n * @description Main entry point for the tomodo backend server.\n * This file initializes the HTTP server, attaches the Express application,\n * sets up Socket.IO for real-time communication, and listens for connections.\n * It also includes graceful shutdown logic for process signals.\n */\n\nimport http from 'http';\nimport app from './app';\nimport config from './config';\nimport logger from './utils/logger';\nimport { initializeSocket } from './services/socket';\n\nconst port = config.port;\nconst host = config.host;\n\n/**\n * Create an HTTP server instance.\n * The Express app is passed as the request handler.\n */\nconst httpServer = http.createServer(app);\n\n/**\n * Initialize and attach Socket.IO to the HTTP server.\n * This enables real-time, bidirectional communication.\n */\ninitializeSocket(httpServer);\n\n/**\n * Start the HTTP server and listen for incoming connections.\n */\nconst server = httpServer.listen(port, host, () => {\n  logger.info(`\ud83d\ude80 Server is running on http://${host}:${port}`);\n  logger.info(`Environment: ${config.env}`);\n});\n\n/**\n * Gracefully shuts down the server.\n * @param {string} signal - The signal received that triggered the shutdown.\n */\nconst gracefulShutdown = (signal: string) => {\n  logger.info(`Received ${signal}. Shutting down gracefully...`);\n  server.close(() => {\n    logger.info('HTTP server closed.');\n    // Here you would close database connections, etc.\n    process.exit(0);\n  });\n};\n\n// Listen for termination signals\nconst signals: NodeJS.Signals[] = ['SIGINT', 'SIGTERM'];\nsignals.forEach((signal) => {\n  process.on(signal, () => gracefulShutdown(signal));\n});\n\n/**\n * Listen for unhandled promise rejections.\n * This is a safety net for catching errors in async operations\n * that were not wrapped in a try/catch block.\n */\nprocess.on('unhandledRejection', (reason: any, promise: Promise<any>) => {\n  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  // In a production environment, you might want to exit the process\n  // after logging the error to avoid an unknown state.\n  // For now, we log it and continue.\n});\n\n/**\n * Listen for uncaught exceptions.\n * This is the last line of defense for errors. If an exception\n * bubbles all the way up, this will catch it.\n */\nprocess.on('uncaughtException', (error: Error) => {\n  logger.error('Uncaught Exception:', error);\n  // It's critical to exit the process after an uncaught exception,\n  // as the application is in an undefined state.\n  gracefulShutdown('uncaughtException');\n});",
    "qa": null
  }
}